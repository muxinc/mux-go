/*
 * Mux API
 *
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * API version: v1
 * Contact: devex@mux.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package muxgo

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AssetsApiService AssetsApi service
type AssetsApiService service

type ApiCreateAssetRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	createAssetRequest *CreateAssetRequest
}

func (r ApiCreateAssetRequest) CreateAssetRequest(createAssetRequest CreateAssetRequest) ApiCreateAssetRequest {
	r.createAssetRequest = &createAssetRequest
	return r
}

func (r ApiCreateAssetRequest) Execute() (AssetResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateAssetExecute(r)
}

/*
 * CreateAsset Create an asset
 * Create a new Mux Video asset.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateAssetRequest
 */
func (a *AssetsApiService) CreateAsset(ctx _context.Context) ApiCreateAssetRequest {
	return ApiCreateAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AssetResponse
 */
func (a *AssetsApiService) CreateAssetExecute(r ApiCreateAssetRequest) (AssetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.CreateAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createAssetRequest == nil {
		return localVarReturnValue, nil, reportError("createAssetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetPlaybackIdRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	createPlaybackIDRequest *CreatePlaybackIDRequest
}

func (r ApiCreateAssetPlaybackIdRequest) CreatePlaybackIDRequest(createPlaybackIDRequest CreatePlaybackIDRequest) ApiCreateAssetPlaybackIdRequest {
	r.createPlaybackIDRequest = &createPlaybackIDRequest
	return r
}

func (r ApiCreateAssetPlaybackIdRequest) Execute() (CreatePlaybackIDResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateAssetPlaybackIdExecute(r)
}

/*
 * CreateAssetPlaybackId Create a playback ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiCreateAssetPlaybackIdRequest
 */
func (a *AssetsApiService) CreateAssetPlaybackId(ctx _context.Context, aSSETID string) ApiCreateAssetPlaybackIdRequest {
	return ApiCreateAssetPlaybackIdRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return CreatePlaybackIDResponse
 */
func (a *AssetsApiService) CreateAssetPlaybackIdExecute(r ApiCreateAssetPlaybackIdRequest) (CreatePlaybackIDResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreatePlaybackIDResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.CreateAssetPlaybackId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/playback-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createPlaybackIDRequest == nil {
		return localVarReturnValue, nil, reportError("createPlaybackIDRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPlaybackIDRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetTrackRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	createTrackRequest *CreateTrackRequest
}

func (r ApiCreateAssetTrackRequest) CreateTrackRequest(createTrackRequest CreateTrackRequest) ApiCreateAssetTrackRequest {
	r.createTrackRequest = &createTrackRequest
	return r
}

func (r ApiCreateAssetTrackRequest) Execute() (CreateTrackResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateAssetTrackExecute(r)
}

/*
 * CreateAssetTrack Create an asset track
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiCreateAssetTrackRequest
 */
func (a *AssetsApiService) CreateAssetTrack(ctx _context.Context, aSSETID string) ApiCreateAssetTrackRequest {
	return ApiCreateAssetTrackRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return CreateTrackResponse
 */
func (a *AssetsApiService) CreateAssetTrackExecute(r ApiCreateAssetTrackRequest) (CreateTrackResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateTrackResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.CreateAssetTrack")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createTrackRequest == nil {
		return localVarReturnValue, nil, reportError("createTrackRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTrackRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAssetRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
}


func (r ApiDeleteAssetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAssetExecute(r)
}

/*
 * DeleteAsset Delete an asset
 * Deletes a video asset and all its data.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiDeleteAssetRequest
 */
func (a *AssetsApiService) DeleteAsset(ctx _context.Context, aSSETID string) ApiDeleteAssetRequest {
	return ApiDeleteAssetRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 */
func (a *AssetsApiService) DeleteAssetExecute(r ApiDeleteAssetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.DeleteAsset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAssetPlaybackIdRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	pLAYBACKID string
}


func (r ApiDeleteAssetPlaybackIdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAssetPlaybackIdExecute(r)
}

/*
 * DeleteAssetPlaybackId Delete a playback ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @param pLAYBACKID The live stream's playback ID.
 * @return ApiDeleteAssetPlaybackIdRequest
 */
func (a *AssetsApiService) DeleteAssetPlaybackId(ctx _context.Context, aSSETID string, pLAYBACKID string) ApiDeleteAssetPlaybackIdRequest {
	return ApiDeleteAssetPlaybackIdRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
		pLAYBACKID: pLAYBACKID,
	}
}

/*
 * Execute executes the request
 */
func (a *AssetsApiService) DeleteAssetPlaybackIdExecute(r ApiDeleteAssetPlaybackIdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.DeleteAssetPlaybackId")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/playback-ids/{PLAYBACK_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"PLAYBACK_ID"+"}", _neturl.PathEscape(parameterToString(r.pLAYBACKID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAssetTrackRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	tRACKID string
}


func (r ApiDeleteAssetTrackRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAssetTrackExecute(r)
}

/*
 * DeleteAssetTrack Delete an asset track
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @param tRACKID The track ID.
 * @return ApiDeleteAssetTrackRequest
 */
func (a *AssetsApiService) DeleteAssetTrack(ctx _context.Context, aSSETID string, tRACKID string) ApiDeleteAssetTrackRequest {
	return ApiDeleteAssetTrackRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
		tRACKID: tRACKID,
	}
}

/*
 * Execute executes the request
 */
func (a *AssetsApiService) DeleteAssetTrackExecute(r ApiDeleteAssetTrackRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.DeleteAssetTrack")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/tracks/{TRACK_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TRACK_ID"+"}", _neturl.PathEscape(parameterToString(r.tRACKID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAssetRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
}


func (r ApiGetAssetRequest) Execute() (AssetResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAssetExecute(r)
}

/*
 * GetAsset Retrieve an asset
 * Retrieves the details of an asset that has previously been created. Supply the unique asset ID that was returned from your previous request, and Mux will return the corresponding asset information. The same information is returned when creating an asset.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiGetAssetRequest
 */
func (a *AssetsApiService) GetAsset(ctx _context.Context, aSSETID string) ApiGetAssetRequest {
	return ApiGetAssetRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return AssetResponse
 */
func (a *AssetsApiService) GetAssetExecute(r ApiGetAssetRequest) (AssetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetInputInfoRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
}


func (r ApiGetAssetInputInfoRequest) Execute() (GetAssetInputInfoResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAssetInputInfoExecute(r)
}

/*
 * GetAssetInputInfo Retrieve asset input info
 * Returns a list of the input objects that were used to create the asset along with any settings that were applied to each input.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiGetAssetInputInfoRequest
 */
func (a *AssetsApiService) GetAssetInputInfo(ctx _context.Context, aSSETID string) ApiGetAssetInputInfoRequest {
	return ApiGetAssetInputInfoRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return GetAssetInputInfoResponse
 */
func (a *AssetsApiService) GetAssetInputInfoExecute(r ApiGetAssetInputInfoRequest) (GetAssetInputInfoResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetAssetInputInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAssetInputInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/input-info"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetPlaybackIdRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	pLAYBACKID string
}


func (r ApiGetAssetPlaybackIdRequest) Execute() (GetAssetPlaybackIDResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAssetPlaybackIdExecute(r)
}

/*
 * GetAssetPlaybackId Retrieve a playback ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @param pLAYBACKID The live stream's playback ID.
 * @return ApiGetAssetPlaybackIdRequest
 */
func (a *AssetsApiService) GetAssetPlaybackId(ctx _context.Context, aSSETID string, pLAYBACKID string) ApiGetAssetPlaybackIdRequest {
	return ApiGetAssetPlaybackIdRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
		pLAYBACKID: pLAYBACKID,
	}
}

/*
 * Execute executes the request
 * @return GetAssetPlaybackIDResponse
 */
func (a *AssetsApiService) GetAssetPlaybackIdExecute(r ApiGetAssetPlaybackIdRequest) (GetAssetPlaybackIDResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetAssetPlaybackIDResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAssetPlaybackId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/playback-ids/{PLAYBACK_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"PLAYBACK_ID"+"}", _neturl.PathEscape(parameterToString(r.pLAYBACKID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssetsRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	limit *int32
	page *int32
	liveStreamId *string
	uploadId *string
}

func (r ApiListAssetsRequest) Limit(limit int32) ApiListAssetsRequest {
	r.limit = &limit
	return r
}
func (r ApiListAssetsRequest) Page(page int32) ApiListAssetsRequest {
	r.page = &page
	return r
}
func (r ApiListAssetsRequest) LiveStreamId(liveStreamId string) ApiListAssetsRequest {
	r.liveStreamId = &liveStreamId
	return r
}
func (r ApiListAssetsRequest) UploadId(uploadId string) ApiListAssetsRequest {
	r.uploadId = &uploadId
	return r
}

func (r ApiListAssetsRequest) Execute() (ListAssetsResponse, *_nethttp.Response, error) {
	return r.ApiService.ListAssetsExecute(r)
}

/*
 * ListAssets List assets
 * List all Mux assets.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListAssetsRequest
 */
func (a *AssetsApiService) ListAssets(ctx _context.Context) ApiListAssetsRequest {
	return ApiListAssetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ListAssetsResponse
 */
func (a *AssetsApiService) ListAssetsExecute(r ApiListAssetsRequest) (ListAssetsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListAssetsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.ListAssets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.liveStreamId != nil {
		localVarQueryParams.Add("live_stream_id", parameterToString(*r.liveStreamId, ""))
	}
	if r.uploadId != nil {
		localVarQueryParams.Add("upload_id", parameterToString(*r.uploadId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssetMasterAccessRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	updateAssetMasterAccessRequest *UpdateAssetMasterAccessRequest
}

func (r ApiUpdateAssetMasterAccessRequest) UpdateAssetMasterAccessRequest(updateAssetMasterAccessRequest UpdateAssetMasterAccessRequest) ApiUpdateAssetMasterAccessRequest {
	r.updateAssetMasterAccessRequest = &updateAssetMasterAccessRequest
	return r
}

func (r ApiUpdateAssetMasterAccessRequest) Execute() (AssetResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateAssetMasterAccessExecute(r)
}

/*
 * UpdateAssetMasterAccess Update master access
 * Allows you to add temporary access to the master (highest-quality) version of the asset in MP4 format. A URL will be created that can be used to download the master version for 24 hours. After 24 hours Master Access will revert to "none".
This master version is not optimized for web and not meant to be streamed, only downloaded for purposes like archiving or editing the video offline.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiUpdateAssetMasterAccessRequest
 */
func (a *AssetsApiService) UpdateAssetMasterAccess(ctx _context.Context, aSSETID string) ApiUpdateAssetMasterAccessRequest {
	return ApiUpdateAssetMasterAccessRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return AssetResponse
 */
func (a *AssetsApiService) UpdateAssetMasterAccessExecute(r ApiUpdateAssetMasterAccessRequest) (AssetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.UpdateAssetMasterAccess")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/master-access"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.updateAssetMasterAccessRequest == nil {
		return localVarReturnValue, nil, reportError("updateAssetMasterAccessRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAssetMasterAccessRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssetMp4SupportRequest struct {
	ctx _context.Context
	ApiService *AssetsApiService
	aSSETID string
	updateAssetMP4SupportRequest *UpdateAssetMP4SupportRequest
}

func (r ApiUpdateAssetMp4SupportRequest) UpdateAssetMP4SupportRequest(updateAssetMP4SupportRequest UpdateAssetMP4SupportRequest) ApiUpdateAssetMp4SupportRequest {
	r.updateAssetMP4SupportRequest = &updateAssetMP4SupportRequest
	return r
}

func (r ApiUpdateAssetMp4SupportRequest) Execute() (AssetResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateAssetMp4SupportExecute(r)
}

/*
 * UpdateAssetMp4Support Update MP4 support
 * Allows you to add or remove mp4 support for assets that were created without it. Currently there are two values supported in this request, `standard` and `none`. `none` means that an asset *does not* have mp4 support, so submitting a request with `mp4_support` set to `none` will delete the mp4 assets from the asset in question.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aSSETID The asset ID.
 * @return ApiUpdateAssetMp4SupportRequest
 */
func (a *AssetsApiService) UpdateAssetMp4Support(ctx _context.Context, aSSETID string) ApiUpdateAssetMp4SupportRequest {
	return ApiUpdateAssetMp4SupportRequest{
		ApiService: a,
		ctx: ctx,
		aSSETID: aSSETID,
	}
}

/*
 * Execute executes the request
 * @return AssetResponse
 */
func (a *AssetsApiService) UpdateAssetMp4SupportExecute(r ApiUpdateAssetMp4SupportRequest) (AssetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.UpdateAssetMp4Support")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/assets/{ASSET_ID}/mp4-support"
	localVarPath = strings.Replace(localVarPath, "{"+"ASSET_ID"+"}", _neturl.PathEscape(parameterToString(r.aSSETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.updateAssetMP4SupportRequest == nil {
		return localVarReturnValue, nil, reportError("updateAssetMP4SupportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAssetMP4SupportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
 * Mux API
 *
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before. 
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package muxgo

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// LiveStreamsApiService LiveStreamsApi service
type LiveStreamsApiService service

type ApiCreateLiveStreamRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	createLiveStreamRequest *CreateLiveStreamRequest
}

func (r ApiCreateLiveStreamRequest) CreateLiveStreamRequest(createLiveStreamRequest CreateLiveStreamRequest) ApiCreateLiveStreamRequest {
	r.createLiveStreamRequest = &createLiveStreamRequest
	return r
}

func (r ApiCreateLiveStreamRequest) Execute() (LiveStreamResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateLiveStreamExecute(r)
}

/*
 * CreateLiveStream Create a live stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateLiveStreamRequest
 */
func (a *LiveStreamsApiService) CreateLiveStream(ctx _context.Context) ApiCreateLiveStreamRequest {
	return ApiCreateLiveStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return LiveStreamResponse
 */
func (a *LiveStreamsApiService) CreateLiveStreamExecute(r ApiCreateLiveStreamRequest) (LiveStreamResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LiveStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.CreateLiveStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createLiveStreamRequest == nil {
		return localVarReturnValue, nil, reportError("createLiveStreamRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLiveStreamRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLiveStreamPlaybackIdRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
	createPlaybackIDRequest *CreatePlaybackIDRequest
}

func (r ApiCreateLiveStreamPlaybackIdRequest) CreatePlaybackIDRequest(createPlaybackIDRequest CreatePlaybackIDRequest) ApiCreateLiveStreamPlaybackIdRequest {
	r.createPlaybackIDRequest = &createPlaybackIDRequest
	return r
}

func (r ApiCreateLiveStreamPlaybackIdRequest) Execute() (CreatePlaybackIDResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateLiveStreamPlaybackIdExecute(r)
}

/*
 * CreateLiveStreamPlaybackId Create a live stream playback ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiCreateLiveStreamPlaybackIdRequest
 */
func (a *LiveStreamsApiService) CreateLiveStreamPlaybackId(ctx _context.Context, lIVESTREAMID string) ApiCreateLiveStreamPlaybackIdRequest {
	return ApiCreateLiveStreamPlaybackIdRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return CreatePlaybackIDResponse
 */
func (a *LiveStreamsApiService) CreateLiveStreamPlaybackIdExecute(r ApiCreateLiveStreamPlaybackIdRequest) (CreatePlaybackIDResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreatePlaybackIDResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.CreateLiveStreamPlaybackId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/playback-ids"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createPlaybackIDRequest == nil {
		return localVarReturnValue, nil, reportError("createPlaybackIDRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPlaybackIDRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLiveStreamSimulcastTargetRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
	createSimulcastTargetRequest *CreateSimulcastTargetRequest
}

func (r ApiCreateLiveStreamSimulcastTargetRequest) CreateSimulcastTargetRequest(createSimulcastTargetRequest CreateSimulcastTargetRequest) ApiCreateLiveStreamSimulcastTargetRequest {
	r.createSimulcastTargetRequest = &createSimulcastTargetRequest
	return r
}

func (r ApiCreateLiveStreamSimulcastTargetRequest) Execute() (SimulcastTargetResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateLiveStreamSimulcastTargetExecute(r)
}

/*
 * CreateLiveStreamSimulcastTarget Create a live stream simulcast target
 * Create a simulcast target for the parent live stream. Simulcast target can only be created when the parent live stream is in idle state. Only one simulcast target can be created at a time with this API.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiCreateLiveStreamSimulcastTargetRequest
 */
func (a *LiveStreamsApiService) CreateLiveStreamSimulcastTarget(ctx _context.Context, lIVESTREAMID string) ApiCreateLiveStreamSimulcastTargetRequest {
	return ApiCreateLiveStreamSimulcastTargetRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return SimulcastTargetResponse
 */
func (a *LiveStreamsApiService) CreateLiveStreamSimulcastTargetExecute(r ApiCreateLiveStreamSimulcastTargetRequest) (SimulcastTargetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SimulcastTargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.CreateLiveStreamSimulcastTarget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/simulcast-targets"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.createSimulcastTargetRequest == nil {
		return localVarReturnValue, nil, reportError("createSimulcastTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSimulcastTargetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLiveStreamRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiDeleteLiveStreamRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteLiveStreamExecute(r)
}

/*
 * DeleteLiveStream Delete a live stream
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiDeleteLiveStreamRequest
 */
func (a *LiveStreamsApiService) DeleteLiveStream(ctx _context.Context, lIVESTREAMID string) ApiDeleteLiveStreamRequest {
	return ApiDeleteLiveStreamRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 */
func (a *LiveStreamsApiService) DeleteLiveStreamExecute(r ApiDeleteLiveStreamRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.DeleteLiveStream")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLiveStreamPlaybackIdRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
	pLAYBACKID string
}


func (r ApiDeleteLiveStreamPlaybackIdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteLiveStreamPlaybackIdExecute(r)
}

/*
 * DeleteLiveStreamPlaybackId Delete a live stream playback ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @param pLAYBACKID The live stream's playback ID.
 * @return ApiDeleteLiveStreamPlaybackIdRequest
 */
func (a *LiveStreamsApiService) DeleteLiveStreamPlaybackId(ctx _context.Context, lIVESTREAMID string, pLAYBACKID string) ApiDeleteLiveStreamPlaybackIdRequest {
	return ApiDeleteLiveStreamPlaybackIdRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
		pLAYBACKID: pLAYBACKID,
	}
}

/*
 * Execute executes the request
 */
func (a *LiveStreamsApiService) DeleteLiveStreamPlaybackIdExecute(r ApiDeleteLiveStreamPlaybackIdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.DeleteLiveStreamPlaybackId")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/playback-ids/{PLAYBACK_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"PLAYBACK_ID"+"}", _neturl.PathEscape(parameterToString(r.pLAYBACKID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLiveStreamSimulcastTargetRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
	sIMULCASTTARGETID string
}


func (r ApiDeleteLiveStreamSimulcastTargetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteLiveStreamSimulcastTargetExecute(r)
}

/*
 * DeleteLiveStreamSimulcastTarget Delete a Live Stream Simulcast Target
 * Delete the simulcast target using the simulcast target ID returned when creating the simulcast target. Simulcast Target can only be deleted when the parent live stream is in idle state.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @param sIMULCASTTARGETID The ID of the simulcast target.
 * @return ApiDeleteLiveStreamSimulcastTargetRequest
 */
func (a *LiveStreamsApiService) DeleteLiveStreamSimulcastTarget(ctx _context.Context, lIVESTREAMID string, sIMULCASTTARGETID string) ApiDeleteLiveStreamSimulcastTargetRequest {
	return ApiDeleteLiveStreamSimulcastTargetRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
		sIMULCASTTARGETID: sIMULCASTTARGETID,
	}
}

/*
 * Execute executes the request
 */
func (a *LiveStreamsApiService) DeleteLiveStreamSimulcastTargetExecute(r ApiDeleteLiveStreamSimulcastTargetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.DeleteLiveStreamSimulcastTarget")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/simulcast-targets/{SIMULCAST_TARGET_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"SIMULCAST_TARGET_ID"+"}", _neturl.PathEscape(parameterToString(r.sIMULCASTTARGETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableLiveStreamRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiDisableLiveStreamRequest) Execute() (DisableLiveStreamResponse, *_nethttp.Response, error) {
	return r.ApiService.DisableLiveStreamExecute(r)
}

/*
 * DisableLiveStream Disable a live stream
 * Disables a live stream, making it reject incoming RTMP streams until re-enabled. The API also ends the live stream recording immediately when active. Ending the live stream recording adds the `EXT-X-ENDLIST` tag to the HLS manifest which notifies the player that this live stream is over.

Mux also closes the encoder connection immediately. Any attempt from the encoder to re-establish connection will fail till the live stream is re-enabled.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiDisableLiveStreamRequest
 */
func (a *LiveStreamsApiService) DisableLiveStream(ctx _context.Context, lIVESTREAMID string) ApiDisableLiveStreamRequest {
	return ApiDisableLiveStreamRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return DisableLiveStreamResponse
 */
func (a *LiveStreamsApiService) DisableLiveStreamExecute(r ApiDisableLiveStreamRequest) (DisableLiveStreamResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DisableLiveStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.DisableLiveStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnableLiveStreamRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiEnableLiveStreamRequest) Execute() (EnableLiveStreamResponse, *_nethttp.Response, error) {
	return r.ApiService.EnableLiveStreamExecute(r)
}

/*
 * EnableLiveStream Enable a live stream
 * Enables a live stream, allowing it to accept an incoming RTMP stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiEnableLiveStreamRequest
 */
func (a *LiveStreamsApiService) EnableLiveStream(ctx _context.Context, lIVESTREAMID string) ApiEnableLiveStreamRequest {
	return ApiEnableLiveStreamRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return EnableLiveStreamResponse
 */
func (a *LiveStreamsApiService) EnableLiveStreamExecute(r ApiEnableLiveStreamRequest) (EnableLiveStreamResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EnableLiveStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.EnableLiveStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveStreamRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiGetLiveStreamRequest) Execute() (LiveStreamResponse, *_nethttp.Response, error) {
	return r.ApiService.GetLiveStreamExecute(r)
}

/*
 * GetLiveStream Retrieve a live stream
 * Retrieves the details of a live stream that has previously been created. Supply the unique live stream ID that was returned from your previous request, and Mux will return the corresponding live stream information. The same information is returned when creating a live stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiGetLiveStreamRequest
 */
func (a *LiveStreamsApiService) GetLiveStream(ctx _context.Context, lIVESTREAMID string) ApiGetLiveStreamRequest {
	return ApiGetLiveStreamRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return LiveStreamResponse
 */
func (a *LiveStreamsApiService) GetLiveStreamExecute(r ApiGetLiveStreamRequest) (LiveStreamResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LiveStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.GetLiveStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveStreamSimulcastTargetRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
	sIMULCASTTARGETID string
}


func (r ApiGetLiveStreamSimulcastTargetRequest) Execute() (SimulcastTargetResponse, *_nethttp.Response, error) {
	return r.ApiService.GetLiveStreamSimulcastTargetExecute(r)
}

/*
 * GetLiveStreamSimulcastTarget Retrieve a Live Stream Simulcast Target
 * Retrieves the details of the simulcast target created for the parent live stream. Supply the unique live stream ID and simulcast target ID that was returned in the response of create simulcast target request, and Mux will return the corresponding information.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @param sIMULCASTTARGETID The ID of the simulcast target.
 * @return ApiGetLiveStreamSimulcastTargetRequest
 */
func (a *LiveStreamsApiService) GetLiveStreamSimulcastTarget(ctx _context.Context, lIVESTREAMID string, sIMULCASTTARGETID string) ApiGetLiveStreamSimulcastTargetRequest {
	return ApiGetLiveStreamSimulcastTargetRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
		sIMULCASTTARGETID: sIMULCASTTARGETID,
	}
}

/*
 * Execute executes the request
 * @return SimulcastTargetResponse
 */
func (a *LiveStreamsApiService) GetLiveStreamSimulcastTargetExecute(r ApiGetLiveStreamSimulcastTargetRequest) (SimulcastTargetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SimulcastTargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.GetLiveStreamSimulcastTarget")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/simulcast-targets/{SIMULCAST_TARGET_ID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"SIMULCAST_TARGET_ID"+"}", _neturl.PathEscape(parameterToString(r.sIMULCASTTARGETID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListLiveStreamsRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	limit *int32
	page *int32
	streamKey *string
}

func (r ApiListLiveStreamsRequest) Limit(limit int32) ApiListLiveStreamsRequest {
	r.limit = &limit
	return r
}
func (r ApiListLiveStreamsRequest) Page(page int32) ApiListLiveStreamsRequest {
	r.page = &page
	return r
}
func (r ApiListLiveStreamsRequest) StreamKey(streamKey string) ApiListLiveStreamsRequest {
	r.streamKey = &streamKey
	return r
}

func (r ApiListLiveStreamsRequest) Execute() (ListLiveStreamsResponse, *_nethttp.Response, error) {
	return r.ApiService.ListLiveStreamsExecute(r)
}

/*
 * ListLiveStreams List live streams
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListLiveStreamsRequest
 */
func (a *LiveStreamsApiService) ListLiveStreams(ctx _context.Context) ApiListLiveStreamsRequest {
	return ApiListLiveStreamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ListLiveStreamsResponse
 */
func (a *LiveStreamsApiService) ListLiveStreamsExecute(r ApiListLiveStreamsRequest) (ListLiveStreamsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListLiveStreamsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.ListLiveStreams")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.streamKey != nil {
		localVarQueryParams.Add("stream_key", parameterToString(*r.streamKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetStreamKeyRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiResetStreamKeyRequest) Execute() (LiveStreamResponse, *_nethttp.Response, error) {
	return r.ApiService.ResetStreamKeyExecute(r)
}

/*
 * ResetStreamKey Reset a live stream’s stream key
 * Reset a live stream key if you want to immediately stop the current stream key from working and create a new stream key that can be used for future broadcasts.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiResetStreamKeyRequest
 */
func (a *LiveStreamsApiService) ResetStreamKey(ctx _context.Context, lIVESTREAMID string) ApiResetStreamKeyRequest {
	return ApiResetStreamKeyRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return LiveStreamResponse
 */
func (a *LiveStreamsApiService) ResetStreamKeyExecute(r ApiResetStreamKeyRequest) (LiveStreamResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LiveStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.ResetStreamKey")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/reset-stream-key"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSignalLiveStreamCompleteRequest struct {
	ctx _context.Context
	ApiService *LiveStreamsApiService
	lIVESTREAMID string
}


func (r ApiSignalLiveStreamCompleteRequest) Execute() (SignalLiveStreamCompleteResponse, *_nethttp.Response, error) {
	return r.ApiService.SignalLiveStreamCompleteExecute(r)
}

/*
 * SignalLiveStreamComplete Signal a live stream is finished
 * (Optional) End the live stream recording immediately instead of waiting for the reconnect_window. `EXT-X-ENDLIST` tag is added to the HLS manifest which notifies the player that this live stream is over.

Mux does not close the encoder connection immediately. Encoders are often configured to re-establish connections immediately which would result in a new recorded asset. For this reason, Mux waits for 60s before closing the connection with the encoder. This 60s timeframe is meant to give encoder operators a chance to disconnect from their end.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lIVESTREAMID The live stream ID
 * @return ApiSignalLiveStreamCompleteRequest
 */
func (a *LiveStreamsApiService) SignalLiveStreamComplete(ctx _context.Context, lIVESTREAMID string) ApiSignalLiveStreamCompleteRequest {
	return ApiSignalLiveStreamCompleteRequest{
		ApiService: a,
		ctx: ctx,
		lIVESTREAMID: lIVESTREAMID,
	}
}

/*
 * Execute executes the request
 * @return SignalLiveStreamCompleteResponse
 */
func (a *LiveStreamsApiService) SignalLiveStreamCompleteExecute(r ApiSignalLiveStreamCompleteRequest) (SignalLiveStreamCompleteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SignalLiveStreamCompleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamsApiService.SignalLiveStreamComplete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/v1/live-streams/{LIVE_STREAM_ID}/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"LIVE_STREAM_ID"+"}", _neturl.PathEscape(parameterToString(r.lIVESTREAMID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
